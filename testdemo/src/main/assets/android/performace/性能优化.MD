


### 特点
1. 性能表现差

2. 线上问题无从排查

3. 性能优化长期开销大



### 1. App 启动优化 ###

https://github.com/JamesLiAndroid/Rocket

App启动慢，慢在哪里，哪些机型慢， 这些机型占比多少，哪些系统版本，占比多少

性能优化
1. 启动时间测量

2. 启动优化时用到的工具

3. 获取耗时方法

4. 开始优化


### 2. App 内存优化 ###

App 内存优化，监控内存抖动，内存泄漏，监控出问题的页面路径，列出出问题的机型，系统版本，以及优化后的对比效果

国内的手机厂商常常会根据手机内存大小来定制各种不同的策略，
比如后台应用的缓存个数，LowMemoryKiller的阈值，常用应用的个数等，
很多低端机反馈卡顿，其实造成卡顿的主要就是内存，由于内存不足，系统频繁杀后台，
也有频繁的内存->文件，文件->内存 的操作，Trace 上很多 BlockIO，
很多平时执行很快的操作，现在执行要很久，再加上部分进程被杀后马上重启，
重启后又被杀，cpu占用就比较高了，

1. 内存优化介绍以及工具选择

2. 内存管理机制

3. 内存抖动

4. 内存泄漏



### 3. App 布局优化 ###


### 4. App 卡顿优化 ###

### 5. App 线程优化 ###
进程调度策略有时候也会影响用户的流畅性，当应用的渲染链路上，有
哪个环节因为某些原因，没有被调度到的时候，很大可能会造成卡顿。

调度不到在 Trace 上的表现是 Runnable，常见的调度不到的情况有：

* 同时运行的进程太多，cpu 这边的几个核处理的任务基本都是满的
* 进程优先级较低
* 调度器过于不灵敏，不能及时响应大任务

另外由于 cpu 引起的卡顿情况还有：

* 从大核心掉落到小核心上，小核心处理能力不足，会造成短暂的卡顿
* 触发温控或者触发低电量，此时某些系统会限制大核的使用，导致卡顿
* 系统锁也是造成卡顿的一大元凶，尤其是 wms 锁和 ams 锁，再加上 binder 通信，relayoutWindow 了解一下？
* 核心频率不足，导致函数执行时间过长导致卡顿
* 大核心被占用，任务又调度不到小核，导致卡顿

系统调优往往需要针对上面的情况做对应的处理，给用户一个好的用户体验。
具体的调优方式，往往跟系统和 Soc 强相关，又涉及到 Kernel 和 功耗，改起来是牵一发而动全身，需要非常谨慎。

#### 渲染线程和主线程
Android 应用的渲染链路上最重要的就是主线程和渲染线程，
主线程就是应用启动时创建的 MainThread，对应的也会创建一个 RenderThread（硬件加速默认开启），
我们平时比较看重的 GPU Profile 那条线，基本就包含了主线程和渲染线程的各个阶段的执行时间，
从 GPU Profile ，就可以很容易看到应用的瓶颈

大部分应用的卡顿都发生在主线程和渲染线程上，比如：

* 较长时间的 input 事件处理
* 较长时间的动画事件处理，比如 ListView 的新 Item 的生成
* 复杂界面的 Measure、 Layout、Draw
* 较大 Bitmap 的频繁 upload
* 复杂渲染指令的执行

很多编程的不好的实现，都可以在上面几个步骤里面体现出来，这些都可以通过 Systrace 看出来。

当前应用的渲染链路上的一切优先级都应该是最高的，后台的进程不应该对其造成影响，
这也是系统优化的核心要素，不过要做到这一点也是比较难的，你很难考虑到所有的情况，
比如有的用户的使用环境就是很复杂，而且都是必须的，这时候就不是很好处理。


### 6. App 网络优化 ###

### 7. App 电量优化 ###

### 8. App 瘦身优化 ###

### 9. App 稳定性优化 ###

### 10. App 专项技术优化 ###









