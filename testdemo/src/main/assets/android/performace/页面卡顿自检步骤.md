


### 1. 布局检测
过度绘制会浪费大量的 CPU 以及 GPU 资源，GPU 绘制影响的是界面的流畅度和用户体验
##### 1）检测
1. 打开设置
    
    设置 -> 开发者选项 -> 调试GPU过度绘制 -> 显示GPU过度绘制
    
2. 回到页面查看页面的颜色情况
        
    蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况
    
        原色： 没有过度绘制
        蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。 
        绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。 
        淡红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。 
        深红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。

3. Layout Inspector 布局检查器 或者 hierarchyviewer(老一些的版本)

    通过Layout Inspector 布局检查器，可以更直观的看到布局的层次结构
    
4. Choreographer

    检测UI丢帧跟卡顿，网上的文章还是很多的


5. 获取界面布局耗时

获取每个界面的加载耗时

 1）常规方式
复写 setContentView(), 


 2）AOP / ArtHook 方式
   切Activity的 setContentView() 方法，

    @Around("execution(* android.app.Activity.setContentView(..))")

 3）获取任意控件加载耗时
   使用LayoutInflate Factory


    
##### 2）处理方式
1. 背景过度绘制

   查看当前布局是否有不必要的背景色
    
    有一点需要注意，Activity 的布局最终会添加在 DecorView 中，这个 View 会中的背景就没有必要了，
    我们可以调用 mDecor.setWindowBackground(drawable);，那么可以在 BaseActivity 调用 getWindow().setBackgroundDrawable(null); 
    或者 getWindow().setBackgroundDrawableResource(android.R.color.transparent)， 然后将颜色都写在布局中

2. 自定义view绘图过度绘制

    可以类似canvas.clipRect这样绘制只需要绘制的部分    

    View的onDraw方法避免耗时的一些操作，
    
--------------------- 


### 2. GPU呈现模式 
 设置 -> 开发者选项 -> GPU呈现模式分析
 
 原则上，线条越短越好，并没有绝对的标准，这里只提供简单直观的方式来说明大概会在哪里比较耗时，并不是精确的
 
 在Android6.0之前，GPU的玄学曲线主要为黄色、红色、蓝色

| 颜色 | 渲染阶段 | 说明 |
|:--------:| :-------- | :--------  |
| <font color="#ED732A">黄 色</font><br /> | 交换缓冲区 | 表示处理任务的时间， 即CPU等待GPU完成任务的时间，线条越高，表示GPU做的事情越多。<br />若橙色部分过高，说明GPU目前过于忙碌 | 
| <font color="#E01E20">红 色</font><br /> | 命令问题  |表示执行任务的时间， 是Android进行2D渲染显示列表的时间，为了将内容绘制到屏幕上，Android需要使用Open GL ES的API接口来绘制显示列表，<br />红色线条越高表示需要绘制的视图更多；比如我们在遇到多张图加载的时候，红色会突然跳的很高，此事滑动页面也就流畅，要等几秒图片才能加载出来，并不是卡住 | 
| <font color="#317BF1">蓝 色</font><br /> | 绘制  |表示测量和绘制视图列表所需要的时间， 蓝色线条越高表示每一帧需要更新很多视图，<br />或者View的onDraw方法中做了耗时操作。它越长说明当前视图比较复杂或者无效需要重绘，表现为卡顿 | 

 6.0 之后
 
| 颜色 | 渲染阶段| 说明 | 
|:--------:| :-------- |  :-------- | 
| <font color="#ED732A">黄 色</font><br /> | 交换缓冲区 | 表示处理任务的时间， 即CPU等待GPU完成任务的时间，线条越高，表示GPU做的事情越多。若橙色部分过高，说明GPU目前过于忙碌 | 
| <font color="#E01E20">红 色</font><br /> | 命令问题 | 表示执行任务的时间， 是Android进行2D渲染显示列表的时间，为了将内容绘制到屏幕上，Android需要使用Open GL ES的API接口来绘制显示列表，<br />红色线条越高表示需要绘制的视图更多；比如我们在遇到多张图加载的时候，红色会突然跳的很高，此事滑动页面也就流畅，要等几秒图片才能加载出来，并不是卡住 | 
| <font color="#317BF1">浅 蓝 色</font><br /> | 同步和上传 | 表示的是准备当前界面上有待绘制的图片位图信息上传到GPU所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片的大小 | 
| <font color="#317BF1">蓝 色</font><br /> | 绘制 | 表示测量和绘制视图列表所需要的时间， 蓝色线条越高表示每一帧需要更新很多视图，或者View的onDraw方法中做了耗时操作。它越长说明当前视图比较复杂或者无效需要重绘，表现为卡顿 | 
| <font color="#00C4A8">绿 色</font><br /> | 绘制 测量 | 布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题 | 
| <font color="#00B799">绿 色</font><br /> | 动画 | 表示计算执行动画所需要花费的时间 | 
| <font color="#02A991">绿 色</font><br /> | 输入处理 | 表示系统处理输入事件所耗费的时间，粗略等于对事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作 | 
| <font color="#02886D">绿 色</font><br />  | 其他时间 | 表示在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况 | 
 
 
### 3. 不合理的设计

    设计和性能往往不可兼得，需要从两者之间做取舍，设计师的设计往往很炫酷，
    互相嵌套的动画往往是程序员的噩梦，为了实现这些复杂的效果，程序员往往
    需要复杂的代码来实现，这对应用的渲染链路的压力是非常大的，而且在不同
    性能的机器上表现差异很大，高端机用户觉得这个效果棒棒哒，低端机用户卡
    的要骂娘。
    

### 4. 内存相关
- adb shell getprop dalvik.vm.heapgrowthlimit 

    单个应用可用最大内存，超出就会报OOM。<font color="#ED732A">这个内存溢出是针对dalvik堆而言，而不是native堆</font><br />

- adb shell getprop dalvik.vm.heapsize  

    单个进程可用的最大内存,表示不受控情况下的极限堆,以heapgrowthsize定义为最大内存, <font color="#ED732A">除非在manifest文件中指定android:largeHeap为true
    </font><br /> 否则，这个值对应用而言没用


- adb shell getprop dalvik.vm.heapstartsize 

    堆分配的初始大小

- adb shell cat /proc/meminfo

    查看总内存跟可用内存
    
    E:\hrl\working\freereader\WTReader\WTReader>adb shell cat /proc/meminfo
    
    MemTotal:        3649368 kB  总内存
    
    MemFree:          221940 kB  可用内存


##### 1）检测内存

   循环反复的进入退出要检测的页面，并在当前页面操作一波

   然后使用Profile 工具检测是否存在内存抖动、内存泄漏等问题

   或者集成leakcanary 工具
   
   内存监测工具
   

##### 2）分析解决问题

### CPU 


https://blog.csdn.net/qq_31242531/article/details/80498311

https://github.com/NetEase/Emmagee

https://github.com/AntonioRedondo/AnotherMonitor



### 进程调度

    请自行搜索学习[线程优化]()工具及方法进行优化
    
### 网络

    请自行搜索学习[网络优化]()工具及方法进行优化
    
### 电量

    请自行搜索学习[电量优化]()工具及方法进行优化


### 内存策略

    国内系统对应用管控、权限等这一块进行了大量的修改，再加上国内应用厂商的全家桶相互唤醒，使得手机后台有
    应用在乱跑，或者有大量的进程常驻，严重影响内存的使用，而且根据手机内存大小不同，所使用的内存的策略也
    不同，比如后台应用的缓存个数、LowMemoryKiller 的阈值、杀进程模块的阈值、显示模块的缓存大小阈值、用户
    最常用应用的个数等。
    
    当内存不足时，系统会频繁杀后台进程，同时伴随有频繁的内存->文件，文件->内存 的操作，再加上部分进程被杀
    之后马上重启，重启之后又被杀，cpu 占用很高，此时就会很卡

### 进程调度

### 渲染线程 & 主线程

    > . 较长时间的 input 事件处理  
      . 较长时间的动画事件处理，比如 ListView 的新 Item 的生成  
      . 复杂界面的 Measure、 Layout、Draw  
      . 较大 Bitmap 的频繁 upload  
      . 复杂渲染指令的执行









