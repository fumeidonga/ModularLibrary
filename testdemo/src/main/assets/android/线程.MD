




## 线程调度原理

任意时刻，只有一个线程占用CPU，处于运行状态，

多线程并发指的是轮流获取CPU使用权，在运行池当中是有多个处于就绪状态的线程

JVM负责线程的调度，按照特定的机制来为多个线程分配CPU的使用权


## 线程调度模型
分时调度模型： 轮流获取，均分CPU的使用时间，

抢占式调度模型：线程优先级高的线程先运行，如果都一样的就随机


## Android 线程调度
- nice值

越小优先级越大, 默认值Process.THREAD_PRIORITY_DEFAULT，当然在实际开发中并不是将优先
级弄的高了就没事，比如有很多后台线程，虽然优先级不高，但是数量多，使得CPU持续消耗，
也会影响整体的性能，所以需要另外一套机制CGROUP

- cgroup

更严格的群组调度策略，前台线程group更优先的使用CPU，

当我们手动设置优先级低的线程或者那些不在前台运行的线程，都会归类到后台线程里面


#### 存在的问题

线程过多或导致CPU的频繁切换，降低运行效率，然后需要决定任务的重要等级，使用哪种优先级，
一般来说线程的优先级跟工作量成反比(工作量越大优先级越低)

线程具有继承性，比如在主线程中创建了一个子线程，其实他们的优先级是一样的


## Android异步方式汇总

#### 1. new Thread
直接new一个，不能复用，频繁创建及销毁开销大， 

#### 2. HandlerThread
本质也是一个Thread，内部使用Handler串行执行

#### 3. IntentService
一个service，内部创建了一个HandlerThread,     优先级比较高

#### 4. AsyncTask 
内部线程池实现，无需自己处理线程切换

#### 5. 线程池
可复用，

#### 6. RXJava


## 线程优化实战

1. 严禁new Thread

2. 提供一个基础线程池

3. 根据任务的类型选择合适的异步方式

eg: 优先级低，长时间执行，HandlerThread， 再比如需要定时执行就可以用线程池

4. 每个线程必须命名，方便定位

5. 关键的异步任务监控

异步并不等于不耗时，我们可以使用AOP的方式来监控

6. 优先级的设置

## 如何锁定线程创建者

#### 1. 创建背景
项目大之后，对线程数量的控制，线程的创建会有很多地方，源码、三方库等，需要对线程的
创建追踪

#### 2. 创建方案 ARTHOOK
创建线程的位置获取堆栈信息，所有的异步都会走到new Thread, 因为不可以改Thread的源码，
所以我们可以使用HOOK的手段，找构造方法或者特定的方法，我们可以HOOK住Thread的构造方法，
在里面加上我们自己的代码，获取调用的堆栈信息


## 线程收敛优雅实践

#### 1. 使用统一的线程库

#### 2. 区分任务类型
 IO 、CPU 密集型
 
 CPU密集型也叫计算密集型，计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力，
 这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算
 密集型任务同时进行的数量应当等于CPU的核心数
 
 IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于
 CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度
 
 IO密集型任务不消耗cpu，比如网络请求，io读写等，核心池可以很大
 
 CPU 密集型并发数就不要超过CPU的核心数。 












