
proxy (p ro k xi)

![](https://github.com/fumeidonga/markdownPic/blob/master/designmodel/proxy.jpg?raw=true)

为目标对象提供一个代理对象，并由代理对象控制目标对象的访问，
通过引入代理对象的方式来间接的访问目标对象

生活中常见的例子：代购，中介等

这又有点像类的适配器模式，

理解

            很明显，适配器模式是因为新旧接口不一致导致出现了客户端无法得到满足的问题，
        但是，由于旧的接口是不能被完全重构掉的，因为我们还想使用实现了这个接口的一些服务。
        那么为了使用以前实现旧接口的服务，我们就应该把新的接口转换成旧接口；
        实现这个转换的类就是抽象意义的转换器。

            就比如在java中早期的枚举接口是Enumeration而后定义的枚举接口是Iterator;
        有很多旧的类实现了enumeration接口暴露出了一些服务，但是这些服务我们现在想通过传入
        Iterator接口而不是Enumeration接口来调用，这时就需要一个适配器，那么client就能
        用这个服务了（服务端只想用Iterator或者只知道这个接口）。

            相比于适配器的应用场景，代理就不一样了，虽然代理也同样是增加了一层，但是，代理
        提供的接口和原本的接口是一样的，代理模式的作用是不把实现直接暴露给client，而是
        通过代理这个层，代理能够做一些处理。

##### 静态代理
在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了

通常情况下，静态代理中的代理类和委托类会实现同一接口或是派生自相同的父类

#### 动态代理
类的源码是在程序运行期间根据反射等机制动态的生成，所以不存在代理类的字节码文件。
代理类和委托类的关系是在程序运行时确定

实现方式：





* 远程代理

为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实

* 虚拟代理

使用一个很小的对象代理一个开销大的对象

* 安全代理

访问权限等控制

* 智能指引

是指当调用真实对象时，代理处理另外一些事

* 防火墙代理

保护目标不让恶意用户靠近，  安全代理？

* cache代理







